// Mega

Texture2D gShadowMap : register(t0);

SamplerState gLinear : register(s0);

cbuffer PerRun : register(cb0)
{
	float4	gColour;
	float	gSpecPwr;
	float	gSpecEms;
};

struct Input
{
	float4 positionCS 	: SV_Position;
	float4 positionWS 	: POSITION;
	float3 normal 		: NORMAL;
	float4 positionTS 	: TEXCOORD;
};

struct Output
{
	float4 position : SV_Target0;
	float4 normal	: SV_Target1;
	float4 diffuse	: SV_Target2;
};

static const int 	r		= 4;

static const int	sz 		= (r * 2) + 1;
static const float 	inc 	= 0.9;			// out of  1.0 max

static const float 	szInc 	= inc / ((float)sz * sz);

static const float 	dx 		= 1.0 / 16000.0;	// always resize to equal shadow texture x, not auto :(
static const float 	dy 		= 1.0 / 9000.0;		// always resize to equal shadow texture y, not auto :(

Output main(Input input)
{
	Output output;
	
	// basic outs
	output.position 	= float4(input.positionWS.xyz, gSpecPwr);
	output.normal		= float4(normalize(input.normal), gSpecEms);
	output.diffuse.xyz	= gColour.xyz;
	
	// shadow test
	float tsDepth = input.positionTS.z - 0.005;
	float total = 0.0;	
	[unroll]
	for (int i = -r; i <= r; ++i)
	{
		[unroll]
		for (int j = -r; j <= r; ++j)
		{
			float smDepth = gShadowMap.Sample(gLinear, input.positionTS.xy + float2(dx * i, dy * j)).r;
			
			if (smDepth < tsDepth)
				total += szInc;
		}
	}
	
	output.diffuse.w = total;
	
	return output;
}