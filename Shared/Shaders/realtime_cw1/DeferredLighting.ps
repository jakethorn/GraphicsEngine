// Mega

Texture2D gPosition : register(t0);
Texture2D gNormal	: register(t1);
Texture2D gDiffuse	: register(t2);

SamplerState gLinear : register(s0);

cbuffer PerFrame : register(cb0)
{
	float3	gLightPos;
	float3	gLightColour;
	float3	gCameraPos;
};

struct Input
{
	float4 position : SV_Position;
	float2 texcoord	: TEXCOORD;
};

const static float3 ambient = float3(0.1, 0.1, 0.1);

float4 main(Input input) : SV_Target
{
	float4 p_and_p 	= gPosition.Sample	(gLinear, input.texcoord);
	float4 n_and_e	= gNormal.Sample  	(gLinear, input.texcoord);
	float3 colour	= gDiffuse.Sample 	(gLinear, input.texcoord).xyz;
	
	float3 position = p_and_p.xyz;
	float specPwr	= p_and_p.w;
	
	float3 normal 	= n_and_e.xyz;
	float specEms 	= n_and_e.w;

	float3 L = normalize(gLightPos);
	float3 C = normalize(gCameraPos - position);
	float3 N = normalize(normal);
	float3 R = reflect(-L, N);
	
	float3 output = colour;
	output *= saturate(dot(L, N)) * gLightColour;			// diffuse
	output += pow(max(0.0, dot(R, C)), specPwr) * specEms;	// specular
	
	// force ambient
	output = max(ambient * colour, output);
	
	// specPwr is used as the alpha here because it is 0 when the render target hasn't been written too and >= 1 when it has been
	return float4(output, specPwr);
}